package data

// AUTOGENERATED BY MOQ - DO NOT EDIT
// github.com/matryer/moq

import (
	"sync"
)

var (
	lockUserStoreMockCount	sync.RWMutex
	lockUserStoreMockCreate	sync.RWMutex
	lockUserStoreMockDelete	sync.RWMutex
	lockUserStoreMockExists	sync.RWMutex
	lockUserStoreMockGet	sync.RWMutex
	lockUserStoreMockGetByEmail	sync.RWMutex
	lockUserStoreMockList	sync.RWMutex
)

// UserStoreMock is a mock implementation of UserStore.
//
//     func TestSomethingThatUsesUserStore(t *testing.T) {
//
//         // make and configure a mocked UserStore
//         mockedUserStore := &UserStoreMock{ 
//             CountFunc: func() (int, error) {
// 	               panic("TODO: mock out the Count method")
//             },
//             CreateFunc: func(user *UserData) error {
// 	               panic("TODO: mock out the Create method")
//             },
//             DeleteFunc: func(id int) error {
// 	               panic("TODO: mock out the Delete method")
//             },
//             ExistsFunc: func(id int) (bool, error) {
// 	               panic("TODO: mock out the Exists method")
//             },
//             GetFunc: func(id int) (*UserData, error) {
// 	               panic("TODO: mock out the Get method")
//             },
//             GetByEmailFunc: func(email string) (*UserData, error) {
// 	               panic("TODO: mock out the GetByEmail method")
//             },
//             ListFunc: func(p *PagedQuery) ([]*UserData, error) {
// 	               panic("TODO: mock out the List method")
//             },
//         }
//
//         // TODO: use mockedUserStore in code that requires UserStore
//         //       and then make assertions.
// 
//     }
type UserStoreMock struct {
	// CountFunc mocks the Count method.
	CountFunc func() (int, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(user *UserData) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(id int) error

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(id int) (bool, error)

	// GetFunc mocks the Get method.
	GetFunc func(id int) (*UserData, error)

	// GetByEmailFunc mocks the GetByEmail method.
	GetByEmailFunc func(email string) (*UserData, error)

	// ListFunc mocks the List method.
	ListFunc func(p *PagedQuery) ([]*UserData, error)

	// calls tracks calls to the methods.
	calls struct {
		// Count holds details about calls to the Count method.
		Count []struct {
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// User is the user argument value.
			User *UserData
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Id is the id argument value.
			Id int
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Id is the id argument value.
			Id int
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Id is the id argument value.
			Id int
		}
		// GetByEmail holds details about calls to the GetByEmail method.
		GetByEmail []struct {
			// Email is the email argument value.
			Email string
		}
		// List holds details about calls to the List method.
		List []struct {
			// P is the p argument value.
			P *PagedQuery
		}
	}
}

// Count calls CountFunc.
func (mock *UserStoreMock) Count() (int, error) {
	if mock.CountFunc == nil {
		panic("moq: UserStoreMock.CountFunc is nil but UserStore.Count was just called")
	}
	callInfo := struct {
	}{
	}
	lockUserStoreMockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	lockUserStoreMockCount.Unlock()
	return mock.CountFunc()
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//     len(mockedUserStore.CountCalls())
func (mock *UserStoreMock) CountCalls() []struct {
	} {
	var calls []struct {
	}
	lockUserStoreMockCount.RLock()
	calls = mock.calls.Count
	lockUserStoreMockCount.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *UserStoreMock) Create(user *UserData) error {
	if mock.CreateFunc == nil {
		panic("moq: UserStoreMock.CreateFunc is nil but UserStore.Create was just called")
	}
	callInfo := struct {
		User *UserData
	}{
		User: user,
	}
	lockUserStoreMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockUserStoreMockCreate.Unlock()
	return mock.CreateFunc(user)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedUserStore.CreateCalls())
func (mock *UserStoreMock) CreateCalls() []struct {
		User *UserData
	} {
	var calls []struct {
		User *UserData
	}
	lockUserStoreMockCreate.RLock()
	calls = mock.calls.Create
	lockUserStoreMockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *UserStoreMock) Delete(id int) error {
	if mock.DeleteFunc == nil {
		panic("moq: UserStoreMock.DeleteFunc is nil but UserStore.Delete was just called")
	}
	callInfo := struct {
		Id int
	}{
		Id: id,
	}
	lockUserStoreMockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	lockUserStoreMockDelete.Unlock()
	return mock.DeleteFunc(id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedUserStore.DeleteCalls())
func (mock *UserStoreMock) DeleteCalls() []struct {
		Id int
	} {
	var calls []struct {
		Id int
	}
	lockUserStoreMockDelete.RLock()
	calls = mock.calls.Delete
	lockUserStoreMockDelete.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *UserStoreMock) Exists(id int) (bool, error) {
	if mock.ExistsFunc == nil {
		panic("moq: UserStoreMock.ExistsFunc is nil but UserStore.Exists was just called")
	}
	callInfo := struct {
		Id int
	}{
		Id: id,
	}
	lockUserStoreMockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	lockUserStoreMockExists.Unlock()
	return mock.ExistsFunc(id)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//     len(mockedUserStore.ExistsCalls())
func (mock *UserStoreMock) ExistsCalls() []struct {
		Id int
	} {
	var calls []struct {
		Id int
	}
	lockUserStoreMockExists.RLock()
	calls = mock.calls.Exists
	lockUserStoreMockExists.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *UserStoreMock) Get(id int) (*UserData, error) {
	if mock.GetFunc == nil {
		panic("moq: UserStoreMock.GetFunc is nil but UserStore.Get was just called")
	}
	callInfo := struct {
		Id int
	}{
		Id: id,
	}
	lockUserStoreMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockUserStoreMockGet.Unlock()
	return mock.GetFunc(id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedUserStore.GetCalls())
func (mock *UserStoreMock) GetCalls() []struct {
		Id int
	} {
	var calls []struct {
		Id int
	}
	lockUserStoreMockGet.RLock()
	calls = mock.calls.Get
	lockUserStoreMockGet.RUnlock()
	return calls
}

// GetByEmail calls GetByEmailFunc.
func (mock *UserStoreMock) GetByEmail(email string) (*UserData, error) {
	if mock.GetByEmailFunc == nil {
		panic("moq: UserStoreMock.GetByEmailFunc is nil but UserStore.GetByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	lockUserStoreMockGetByEmail.Lock()
	mock.calls.GetByEmail = append(mock.calls.GetByEmail, callInfo)
	lockUserStoreMockGetByEmail.Unlock()
	return mock.GetByEmailFunc(email)
}

// GetByEmailCalls gets all the calls that were made to GetByEmail.
// Check the length with:
//     len(mockedUserStore.GetByEmailCalls())
func (mock *UserStoreMock) GetByEmailCalls() []struct {
		Email string
	} {
	var calls []struct {
		Email string
	}
	lockUserStoreMockGetByEmail.RLock()
	calls = mock.calls.GetByEmail
	lockUserStoreMockGetByEmail.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *UserStoreMock) List(p *PagedQuery) ([]*UserData, error) {
	if mock.ListFunc == nil {
		panic("moq: UserStoreMock.ListFunc is nil but UserStore.List was just called")
	}
	callInfo := struct {
		P *PagedQuery
	}{
		P: p,
	}
	lockUserStoreMockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	lockUserStoreMockList.Unlock()
	return mock.ListFunc(p)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//     len(mockedUserStore.ListCalls())
func (mock *UserStoreMock) ListCalls() []struct {
		P *PagedQuery
	} {
	var calls []struct {
		P *PagedQuery
	}
	lockUserStoreMockList.RLock()
	calls = mock.calls.List
	lockUserStoreMockList.RUnlock()
	return calls
}
